#pragma once

#include <map>
#include <queue>
#include <array>
#include <future>
#include "BuildList.h"

using std::priority_queue;
using std::map;
using std::shared_ptr;
using std::array;
using std::future;
using std::chrono::system_clock;
using time_point = std::chrono::time_point<system_clock>;
using std::async;
using std::uniform_int_distribution;
using std::max_element;
using std::max;
using std::atomic_size_t;
using std::atomic_fetch_add;
using std::tie;
using std::ignore;
using std::unique_lock;
using std::unique_ptr;

template<
        unsigned POPULATION_SIZE,       // size of each population
        unsigned SELECTION_COUNT,       // number of items directly selected for the next generation
        unsigned MUTATION_COUNT,        // number of items of the next generation generated by mutation
        unsigned REPRODUCTION_COUNT,    // number of items of the next generation generated by reproduction
        unsigned NUM_THREADS,           // number of threads to spawn
        unsigned INIT_BL_LENGTH        // length of initial build lists
>
class Optimizer {

public:

    /**
     * Represents a fitness value
     */
    using fitness_t = float;

    /**
     * Represents an individual subject to the optimization
     */
    struct Individual {
        BuildList buildList;
        fitness_t fitness;

        Individual(BuildList bl, fitness_t f) : buildList(bl), fitness(f) {}
    };

    /**
     * Construct the optimizer
     *
     * @param manager A GameObjectManager instance
     * @param strategy The optimization strategy (true = push, false = rush)
     * @param targetObject The optimization target
     * @param simulateIter Number of iterations to simulate at maximum
     */
    Optimizer(shared_ptr<GameObjectManager> manager, bool strategy, TypeID *targetObject, unsigned simulateIter) :
            _manager(manager), _strategy(strategy), _targetObject(targetObject), _simulateIter(simulateIter) {
		
		
        populate(
                [this](mt19937 &rand) -> BuildList {
                    return BuildList::getStrategicRandomBuildList(INIT_BL_LENGTH, _strategy, _targetObject, _manager,
                                                                  rand);
                },
                _population,
                POPULATION_SIZE
        );

        _population.sort();
    }

    /**
     * Run optimization until specified timeout_time has been reached
     *
     * @param timeout_time
     */
    void run(const time_point &timeout_time) {
        while (system_clock::now() < timeout_time) {
            auto h = async(std::launch::async, iterate);
            auto s = h.wait_until(timeout_time);
            if (s == std::future_status::ready)
                _population = h.get();
        }
    }

    /**
     * Run optimization until number of iterations has been reached
     *
     * @param num_iterations
     */
    void run(unsigned num_iterations) {
        for (int i = 0; i < num_iterations; ++i) {
            auto h = async(std::launch::async, [this]() -> Population {return iterate();});
            h.wait();
            _population = h.get();
        }
    }

    /**
     * Access the current population ordered by decreasing fitness. I.e. result()[0].buildList
     * gives the build list with the highest fitness.
     *
     * @return The current ordered population
     */
    const vector<Individual> &result() const {
        return _population._individuals;
    }

protected:

    /**
     * Function signature of a build list source
     */
    using bl_source_t = std::function<BuildList(mt19937 &)>;

    /**
     * A pair that can be used for reproduction consists of two individuals
     */
    using reproduction_pair_t = pair<Individual, Individual>;

    /**
     * Represents the population of individuals during one iteration and provides convenience methods.
     */
    struct Population {

        /**
         * Allow for fast lookup if some build list exists
         */
        set<BuildList> _individuals_keys;

        /**
         * Store individuals (ordered by decreasing fitness after sort() has been invoked
         */
        vector<Individual> _individuals;

        /**
         * Number of workers in build list with the highest number of workers
         */
        unsigned _highestWorkerCount = 0;

        /**
         * Individual with the highest number of workers
         */
        unique_ptr<Individual> _mostWorkersIndividual;

        mutex _mutex;

        /**
         * Lock to guard parallel access to _individual*
         */
        unique_lock<mutex> _lock = unique_lock<mutex>(_mutex);

        /**
         * Explicit generation of default constructor
         */
        Population() {
            _lock.unlock();
        };

        /**
         * We need a copy constructor..
         */
        Population(const Population &p)
                : _individuals_keys(p._individuals_keys), _individuals(p._individuals),
                  _highestWorkerCount(p._highestWorkerCount) {
            Population();
            if (!p._mostWorkersIndividual) {
                _mostWorkersIndividual = unique_ptr<Individual>();
            }
            else {
                _mostWorkersIndividual = unique_ptr<Individual>(
                        new Individual(p._mostWorkersIndividual->buildList, p._mostWorkersIndividual->fitness)
                );
            }
        }

        /**
         * .. and copy assignment
         */
        Population &operator=(const Population &rhs) {
            if (this != &rhs) {
                Population(rhs);
            }

            return *this;
        }

        /**
         * Thread safe method to add a BL to the population
         *
         * @param list
         * @return True, if list could be added (not a dublicate), otherwise false
         */
        bool guardedAdd(const Individual &subject) {
            _lock.lock();
            auto res = add(subject);
            _lock.unlock();

            return res;
        }

        /**
         * Non-thread safe method to add a BL to the population
         *
         * @param list
         * @return True, if list could be added (not a dublicate), otherwise false
         */
        bool add(const Individual &subject) {
            auto res = _individuals_keys.insert(subject.buildList);
            if (res.second) {
                _individuals.push_back(subject);

                if (subject.buildList.getWorkerCount() > _highestWorkerCount) {
                    _highestWorkerCount = subject.buildList.getWorkerCount();
                    _mostWorkersIndividual = unique_ptr<Individual>(new Individual(subject));
                }

                return true;
            }

            return false;
        }

        /**
         * Sort _individuals by decreasing fitness
         */
        void sort() {
            std::sort(_individuals.begin(), _individuals.end(),
                      [](const Individual &a, const Individual &b) -> bool {
                          return a.fitness > b.fitness;
                      });
        }

        const Individual &get(unsigned index) const {
            return _individuals.at(index);
        };

        /**
         * Get a random candidate
         *
         * @param rnd Instance of random number generator
         * @param limit Upper bound of the section of _individuals that we draw from
         * @return
         */
        const Individual &random(mt19937 &rnd, unsigned limit = POPULATION_SIZE) const {
            uniform_int_distribution<int> dis(0, limit);
            return _individuals.at(dis(rnd));
        }

        /**
         * Get a random pair from the population (according to the procedure described in the paper)
         *
         * @param rnd Instance of random number generator
         * @return
         */
        reproduction_pair_t getReproductionPair(mt19937 &rnd) const {
            auto cands = vector<Individual>{random(rnd), random(rnd), random(rnd), random(rnd)};

            auto pairs = vector<reproduction_pair_t >{
                    make_pair(cands[0], cands[1]),
                    make_pair(cands[0], cands[2]),
                    make_pair(cands[0], cands[3]),
                    make_pair(cands[1], cands[2]),
                    make_pair(cands[1], cands[3]),
                    make_pair(cands[2], cands[3]),
            };

            return *max_element(pairs.begin(), pairs.end(),
                                [](const reproduction_pair_t &a, const reproduction_pair_t &b) -> bool {
                                    return a.first.buildList.distance(a.second.buildList)
                                           < b.first.buildList.distance(b.second.buildList);
                                }
            );
        };

        /**
         * Get the size of the population
         *
         * @return
         */
        size_t size() {
            return _individuals.size();
        }

        /**
         * BL with the most workers among all
         *
         * @return
         */
        Individual &getMostWorkerBL() {
            if (!_mostWorkersIndividual)
                throw std::logic_error("_mostWorkersIndividual not set");

            return *_mostWorkersIndividual;
        }

    };

    /**
     * An instance of the GameObjectManager
     */
    shared_ptr<GameObjectManager> _manager;

    /**
     * The optimization strategy: push strategy if true,  or rush (false)
     */
    bool _strategy;

    /**
     * The optimization target
     */
    TypeID *_targetObject;

    /**
     * The number of iterations to simulate
     */
    unsigned _simulateIter;

    /**
     * The current population
     */
    Population _population;

    /**
     * Array of NUM_THREADS random generators
     */
    array<mt19937, NUM_THREADS> _random;

    /**
     * Calculate the fitness of the given BuildList
     *
     * @param bl
     * @param seconds The time steps needed to simulate the build list
     * @return
     */
    fitness_t fitness(BuildList &bl, unsigned seconds) {
        auto cnt = bl.getOccurrences(_targetObject);

        if (_strategy) { // push
            // TODO: This approach is very simplistic and will lead to many zero fitness build lists.. Not good..
            return (cnt > 0) ? seconds : 0.0f;
        } else { // rush
            return (cnt > 0) ? 1 / cnt : 0.0f;
        }
    }

    /**
     * Populate the current population by drawing items
     * from source, running the simulation and adding them to target
     * until the target size exceeds limit
     *
     * @param source
     * @param target
     * @param limit
     */
    void populate(bl_source_t source, Population &target, size_t limit) {
        atomic_size_t cnt(target.size());

        auto target_p = &target;
        auto cnt_p = &cnt;

        auto wait_all = vector<future<void>>();

        for (int i = 0; i < NUM_THREADS; ++i) {
            auto h = async(std::launch::async, [=]() mutable -> void {
                while (atomic_fetch_add<size_t>(cnt_p, 1) < limit) {
                    auto sim = Simulator();
                    auto bl = source(_random[i]);
                    sim.create(_manager, bl);

                    unsigned it;
                    tie(ignore, it, ignore) = sim.run(_simulateIter);

                    target_p->guardedAdd(Individual(bl, fitness(bl, it)));
                }
            });

            wait_all.push_back(move(h));
        }

        // wait for threads to complete
        for (auto &f: wait_all) {
            f.wait();
        }
    };

    /**
     * Processes one iteration of the genetic algorithm and returns the new population
     *
     * @return
     */
    Population iterate() {
        auto result = Population();

        // selection
        try {
            result.add(_population.getMostWorkerBL());
        } catch(...) {

        }

        cout << _population.size() << endl;
        {
            unsigned i = 0;
            while (result.size() < SELECTION_COUNT) {
                result.add(_population.get(i++));
            }
        }
        // end selection

        // reproduction
        {
            populate([=](mt19937 &rand) -> BuildList {
                         while (true) {
                             try {
                                 auto pair = _population.getReproductionPair(rand);
                                 return pair.first.buildList.crossover(pair.second.buildList, rand);
                             }
                             catch (...) {}
                         }
                     },
                     result,
                     SELECTION_COUNT + REPRODUCTION_COUNT
            );
        }
        // end reproduction

        // begin mutation
        {
            populate([=](mt19937 &rand) -> BuildList {
                         while (true) {
                             try {
                                 return _population.random(
                                         rand, SELECTION_COUNT).buildList.strategicMutate(0.1, _strategy,
                                                                                          _targetObject,
                                                                                          rand
                                 );
                             }
                             catch (...) {}
                         }
                     },
                     result,
                     SELECTION_COUNT + REPRODUCTION_COUNT + MUTATION_COUNT);
        }
        // end mutation

        // sort result by decreasing fitness
        result.sort();

        return result;
    }

};


